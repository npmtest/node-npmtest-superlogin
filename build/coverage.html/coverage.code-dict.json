{"/home/travis/build/npmtest/node-npmtest-superlogin/test.js":"/* istanbul instrument in package npmtest_superlogin */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-superlogin/lib.npmtest_superlogin.js":"/* istanbul instrument in package npmtest_superlogin */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_superlogin = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_superlogin = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-superlogin/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-superlogin && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_superlogin */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_superlogin\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_superlogin.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_superlogin.rollup.js'] =\n            local.assetsDict['/assets.npmtest_superlogin.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_superlogin.__dirname + '/lib.npmtest_superlogin.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/lib/index.js":"'use strict';\nvar events = require('events');\nvar express = require('express');\nvar BPromise = require('bluebird');\nvar PouchDB = require('pouchdb');\nvar seed = require('pouchdb-seed-design');\n\nvar Configure = require('./configure');\nvar User = require('./user');\nvar Oauth = require('./oauth');\nvar loadRoutes = require('./routes');\nvar localConfig = (require('./local'));\nvar Middleware = require('./middleware');\nvar Mailer = require('./mailer');\nvar util = require('./util');\n\nmodule.exports = function (configData, passport, userDB, couchAuthDB) {\n\n  var config = new Configure(configData, require('../config/default.config'));\n  var router = express.Router();\n  var emitter = new events.EventEmitter();\n\n  if(!passport || typeof passport !== 'object') {\n    passport = require('passport');\n  }\n  var middleware = new Middleware(passport);\n\n  // Some extra default settings if no config object is specified\n  if(!configData) {\n    config.setItem('testMode.noEmail', true);\n    config.setItem('testMode.debugEmail', true);\n  }\n\n  // Create the DBs if they weren't passed in\n  if(!userDB && config.getItem('dbServer.userDB')) {\n    userDB = new PouchDB(util.getFullDBURL(config.getItem('dbServer'), config.getItem('dbServer.userDB')));\n  }\n  if(!couchAuthDB && config.getItem('dbServer.couchAuthDB') && !config.getItem('dbServer.cloudant')) {\n    couchAuthDB = new PouchDB(util.getFullDBURL(config.getItem('dbServer'), config.getItem('dbServer.couchAuthDB')));\n  }\n  if(!userDB || typeof userDB !== 'object') {\n    throw new Error('userDB must be passed in as the third argument or specified in the config file under dbServer.userDB');\n  }\n\n  var mailer = new Mailer(config);\n  var user = new User(config, userDB, couchAuthDB, mailer, emitter);\n  var oauth = new Oauth(router, passport, user, config);\n\n  // Seed design docs for the user database\n  var userDesign = require('../designDocs/user-design');\n  userDesign = util.addProvidersToDesignDoc(config, userDesign);\n  seed(userDB, userDesign);\n  // Configure Passport local login and api keys\n  localConfig(config, passport, user);\n  // Load the routes\n  loadRoutes(config, router, passport, user);\n\n  var superlogin = {\n    config: config,\n    router: router,\n    passport: passport,\n    userDB: userDB,\n    couchAuthDB: couchAuthDB,\n    registerProvider: oauth.registerProvider,\n    registerOAuth2: oauth.registerOAuth2,\n    registerTokenProvider: oauth.registerTokenProvider,\n    validateUsername: user.validateUsername,\n    validateEmail: user.validateEmail,\n    validateEmailUsername: user.validateEmailUsername,\n    getUser: user.get,\n    createUser: user.create,\n    onCreate: user.onCreate,\n    socialAuth: user.socialAuth,\n    hashPassword: util.hashPassword,\n    verifyPassword: util.verifyPassword,\n    createSession: user.createSession,\n    changePassword: user.changePassword,\n    changeEmail: user.changeEmail,\n    resetPassword: user.resetPassword,\n    forgotPassword: user.forgotPassword,\n    verifyEmail: user.verifyEmail,\n    addUserDB: user.addUserDB,\n    removeUserDB: user.removeUserDB,\n    logoutUser: user.logoutUser,\n    logoutSession: user.logoutSession,\n    logoutOthers: user.logoutOthers,\n    removeUser: user.remove,\n    confirmSession: user.confirmToken,\n    removeExpiredKeys: user.removeExpiredKeys,\n    sendEmail: mailer.sendEmail,\n    quitRedis: user.quitRedis,\n    // authentication middleware\n    requireAuth: middleware.requireAuth,\n    requireRole: middleware.requireRole,\n    requireAnyRole: middleware.requireAnyRole,\n    requireAllRoles: middleware.requireAllRoles,\n  };\n\n  // Inherit emitter\n  for(var key in emitter) {\n    superlogin[key] = emitter[key];\n  }\n  return superlogin;\n\n};","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/lib/configure.js":"'use strict';\nvar util = require('./util');\n\nmodule.exports = function(data, defaults) {\n\n  this.config = data || {};\n  this.defaults = defaults || {};\n\n  this.getItem = function(key) {\n    var result = util.getObjectRef(this.config, key);\n    if(typeof result === 'undefined' || result === null) {\n      result = util.getObjectRef(this.defaults, key);\n    }\n    return result;\n  };\n\n  this.setItem = function(key, value) {\n    return util.setObjectRef(this.config, key, value);\n  };\n\n  this.removeItem = function(key) {\n    return util.delObjectRef(this.config, key);\n  };\n\n};","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/lib/util.js":"'use strict';\n\nvar BPromise = require('bluebird');\nvar URLSafeBase64 = require('urlsafe-base64');\nvar uuid = require('node-uuid');\nvar pwd = require('couch-pwd');\n\nexports.URLSafeUUID = function() {\n  return URLSafeBase64.encode(uuid.v4(null, new Buffer(16)));\n};\n\nexports.hashPassword = function (password) {\n  return new BPromise(function (resolve, reject) {\n    pwd.hash(password, function (err, salt, hash) {\n      if (err) {\n        return reject(err);\n      }\n      return resolve({\n        salt: salt,\n        derived_key: hash\n      });\n    });\n  });\n};\n\nexports.verifyPassword = function (hashObj, password) {\n  var getHash = BPromise.promisify(pwd.hash, {context: pwd});\n  var iterations = hashObj.iterations;\n  var salt = hashObj.salt;\n  var derived_key = hashObj.derived_key;\n  if (iterations) {\n    pwd.iterations(iterations);\n  }\n  if(!salt || !derived_key) {\n    return BPromise.reject(false);\n  }\n  return getHash(password, salt)\n    .then(function (hash) {\n      if (hash === derived_key) {\n        return BPromise.resolve(true);\n      } else {\n        return BPromise.reject(false);\n      }\n    });\n};\n\nexports.getDBURL = function(db) {\n  var url;\n  if(db.user) {\n    url = db.protocol + encodeURIComponent(db.user) + ':' + encodeURIComponent(db.password) + '@' + db.host;\n  } else {\n    url = db.protocol + db.host;\n  }\n  return url;\n};\n\nexports.getFullDBURL = function(dbConfig, dbName) {\n  return exports.getDBURL(dbConfig) + '/' + dbName;\n};\n\nexports.toArray = function(obj) {\n  if(!(obj instanceof Array)) {\n    obj = [obj];\n  }\n  return obj;\n};\n\nexports.getSessions = function(userDoc) {\n  var sessions = [];\n  if(userDoc.session) {\n    Object.keys(userDoc.session).forEach(function(mySession) {\n      sessions.push(mySession);\n    });\n  }\n  return sessions;\n};\n\nexports.getExpiredSessions = function(userDoc, now) {\n  var sessions = [];\n  if(userDoc.session) {\n    Object.keys(userDoc.session).forEach(function(mySession) {\n      if(userDoc.session[mySession].expires <= now) {\n        sessions.push(mySession);\n      }\n    });\n  }\n  return sessions;\n};\n\n// Takes a req object and returns the bearer token, or undefined if it is not found\nexports.getSessionToken = function(req) {\n  if (req.headers && req.headers.authorization) {\n    var parts = req.headers.authorization.split(' ');\n    if (parts.length == 2) {\n      var scheme = parts[0];\n      var credentials = parts[1];\n      if (/^Bearer$/i.test(scheme)) {\n        var parse = credentials.split(':');\n        if(parse.length < 2) {\n          return;\n        }\n        return parse[0];\n      }\n    }\n  }\n};\n\n// Generates views for each registered provider in the user design doc\nexports.addProvidersToDesignDoc = function(config, ddoc) {\n  var providers = config.getItem('providers');\n  if(!providers) {\n    return ddoc;\n  }\n  var ddocTemplate =\n    \"function(doc) {\\n\" +\n    \"  if(doc.%PROVIDER% && doc.%PROVIDER%.profile) {\\n\" +\n    \"    emit(doc.%PROVIDER%.profile.id, null);\\n\" +\n    \"  }\\n\" +\n    \"}\";\n  Object.keys(providers).forEach(function(provider) {\n    ddoc.auth.views[provider] = ddocTemplate.replace(new RegExp('%PROVIDER%', 'g'), provider);\n  });\n  return ddoc;\n};\n\n// Capitalizes the first letter of a string\nexports.capitalizeFirstLetter = function(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n/**\n * Access nested JavaScript objects with string key\n * http://stackoverflow.com/questions/6491463/accessing-nested-javascript-objects-with-string-key\n *\n * @param {object} obj The base object you want to get a reference to\n * @param {string} str The string addressing the part of the object you want\n * @return {object|undefined} a reference to the requested key or undefined if not found\n */\n\nexports.getObjectRef = function(obj, str) {\n  str = str.replace(/\\[(\\w+)\\]/g, '.$1'); // convert indexes to properties\n  str = str.replace(/^\\./, '');           // strip a leading dot\n  var pList = str.split('.');\n  while (pList.length) {\n    var n = pList.shift();\n    if (n in obj) {\n      obj = obj[n];\n    } else {\n      return;\n    }\n  }\n  return obj;\n};\n\n/**\n * Dynamically set property of nested object\n * http://stackoverflow.com/questions/18936915/dynamically-set-property-of-nested-object\n *\n * @param {object} obj The base object you want to set the property in\n * @param {string} str The string addressing the part of the object you want\n * @param {*} val The value you want to set the property to\n * @return {*} the value the reference was set to\n */\n\nexports.setObjectRef = function(obj, str, val) {\n  str = str.replace(/\\[(\\w+)\\]/g, '.$1'); // convert indexes to properties\n  str = str.replace(/^\\./, '');           // strip a leading dot\n  var pList = str.split('.');\n  var len = pList.length;\n  for(var i = 0; i < len-1; i++) {\n    var elem = pList[i];\n    if( !obj[elem] ) {\n      obj[elem] = {};\n    }\n    obj = obj[elem];\n  }\n  obj[pList[len-1]] = val;\n  return val;\n};\n\n/**\n * Dynamically delete property of nested object\n *\n * @param {object} obj The base object you want to set the property in\n * @param {string} str The string addressing the part of the object you want\n * @return {boolean} true if successful\n */\n\nexports.delObjectRef = function(obj, str) {\n  str = str.replace(/\\[(\\w+)\\]/g, '.$1'); // convert indexes to properties\n  str = str.replace(/^\\./, '');           // strip a leading dot\n  var pList = str.split('.');\n  var len = pList.length;\n  for(var i = 0; i < len-1; i++) {\n    var elem = pList[i];\n    if( !obj[elem] ) {\n      return false;\n    }\n    obj = obj[elem];\n  }\n  delete obj[pList[len-1]];\n  return true;\n};\n\n/**\n * Concatenates two arrays and removes duplicate elements\n *\n * @param {array} a First array\n * @param {array} b Second array\n * @return {array} resulting array\n */\n\nexports.arrayUnion = function (a, b) {\n  var result = a.concat(b);\n  for(var i=0; i<result.length; ++i) {\n    for(var j=i+1; j<result.length; ++j) {\n      if(result[i] === result[j])\n        result.splice(j--, 1);\n    }\n  }\n  return result;\n};","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/lib/user.js":"'use strict';\n\nvar url = require('url');\nvar BPromise = require('bluebird');\nvar Model = require('sofa-model');\nvar nodemailer = require('nodemailer');\nvar extend = require('extend');\nvar Session = require('./session');\nvar util = require('./util');\nvar DBAuth = require('./dbauth');\n\n// regexp from https://github.com/angular/angular.js/blob/master/src/ng/directive/input.js#L4\nvar EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,6}$/;\nvar USER_REGEXP = /^[a-z0-9_-]{3,16}$/;\n\nmodule.exports = function (config, userDB, couchAuthDB, mailer, emitter) {\n\n  var self = this;\n  var dbAuth = new DBAuth(config, userDB, couchAuthDB);\n  var session = new Session(config);\n  var onCreateActions = [];\n  var onLinkActions = [];\n\n  // Token valid for 24 hours by default\n  // Forget password token life\n  var tokenLife = config.getItem('security.tokenLife') || 86400;\n  // Session token life\n  var sessionLife = config.getItem('security.sessionLife') || 86400;\n\n  var emailUsername = config.getItem('local.emailUsername');\n\n\n  this.validateUsername = function (username) {\n    if (!username) {\n      return BPromise.resolve();\n    }\n    if (!username.match(USER_REGEXP)) {\n      return BPromise.resolve('Invalid username');\n    }\n    return userDB.query('auth/username', {key: username})\n      .then(function (result) {\n        if (result.rows.length === 0) {\n          // Pass!\n          return BPromise.resolve();\n        }\n        else {\n          return BPromise.resolve('already in use');\n        }\n      }, function (err) {\n        throw new Error(err);\n      });\n  };\n\n  this.validateEmail = function (email) {\n    if (!email) {\n      return BPromise.resolve();\n    }\n    if (!email.match(EMAIL_REGEXP)) {\n      return BPromise.resolve('invalid email');\n    }\n    return userDB.query('auth/email', {key: email})\n      .then(function (result) {\n        if (result.rows.length === 0) {\n          // Pass!\n          return BPromise.resolve();\n        }\n        else {\n          return BPromise.resolve('already in use');\n        }\n      }, function (err) {\n        throw new Error(err);\n      });\n  };\n\n  this.validateEmailUsername = function (email) {\n    if (!email) {\n      return BPromise.resolve();\n    }\n    if (!email.match(EMAIL_REGEXP)) {\n      return BPromise.resolve('invalid email');\n    }\n    return userDB.query('auth/emailUsername', {key: email})\n      .then(function (result) {\n        if (result.rows.length === 0) {\n          return BPromise.resolve();\n        }\n        else {\n          return BPromise.resolve('already in use');\n        }\n      }, function (err) {\n        throw new Error(err);\n      });\n  };\n\n  // Validation function for ensuring that two fields match\n  this.matches = function(value, option, key, attributes) {\n    if (attributes && attributes[option] !== value) {\n      return \"does not match \" + option;\n    }\n  };\n\n  var passwordConstraints = {\n    presence: true,\n    length: {\n      minimum: 6,\n      message: \"must be at least 6 characters\"\n    },\n    matches: 'confirmPassword'\n  };\n\n  var userModel = {\n    async: true,\n    whitelist: [\n      'name',\n      'username',\n      'email',\n      'password',\n      'confirmPassword'\n    ],\n    customValidators: {\n      validateEmail: self.validateEmail,\n      validateUsername: self.validateUsername,\n      validateEmailUsername: self.validateEmailUsername,\n      matches: self.matches\n    },\n    sanitize: {\n      name: ['trim'],\n      username: ['trim', 'toLowerCase'],\n      email: ['trim', 'toLowerCase']\n    },\n    validate: {\n      email: {\n        presence: true,\n        validateEmail: true\n      },\n      username: {\n        presence: true,\n        validateUsername: true\n      },\n      password: passwordConstraints,\n      confirmPassword: {\n        presence: true\n      }\n    },\n    static: {\n      type: 'user',\n      roles: config.getItem('security.defaultRoles'),\n      providers: ['local']\n    },\n    rename: {\n      username: '_id'\n    }\n  };\n\n  if(emailUsername) {\n    delete userModel.validate.username;\n    delete userModel.validate.email.validateEmail;\n    delete userModel.rename.username;\n    userModel.validate.email.validateEmailUsername = true;\n  }\n\n  var resetPasswordModel = {\n    async: true,\n    customValidators: {\n      matches: self.matches\n    },\n    validate: {\n      token: {\n        presence: true\n      },\n      password: passwordConstraints,\n      confirmPassword: {\n        presence: true\n      }\n    }\n  };\n\n  var changePasswordModel = {\n    async: true,\n    customValidators: {\n      matches: self.matches\n    },\n    validate: {\n      newPassword: passwordConstraints,\n      confirmPassword: {\n        presence: true\n      }\n    }\n  };\n\n  this.onCreate = function(fn) {\n    if(typeof fn === 'function') {\n      onCreateActions.push(fn);\n    } else {\n      throw new TypeError('onCreate: You must pass in a function');\n    }\n  };\n\n  this.onLink = function(fn) {\n    if(typeof fn === 'function') {\n      onLinkActions.push(fn);\n    } else {\n      throw new TypeError('onLink: You must pass in a function');\n    }\n  };\n\n  function processTransformations(fnArray, userDoc, provider) {\n    var promise;\n    fnArray.forEach(function(fn) {\n      if(!promise) {\n        promise = fn.call(null, userDoc, provider);\n      } else {\n        if(!promise.then || typeof promise.then !== 'function') {\n          throw new Error('onCreate function must return a promise');\n        }\n        promise.then(function(newUserDoc) {\n          return fn.call(null, newUserDoc, provider);\n        });\n      }\n    });\n    if(!promise) {\n      promise = BPromise.resolve(userDoc);\n    }\n    return promise;\n  }\n\n  this.get = function (login) {\n    var query;\n    if(emailUsername) {\n      query = 'emailUsername';\n    } else {\n      query = EMAIL_REGEXP.test(login) ? 'email' : 'username';\n    }\n    return userDB.query('auth/' + query, {key: login, include_docs: true})\n      .then(function (results) {\n        if (results.rows.length > 0) {\n          return BPromise.resolve(results.rows[0].doc);\n        } else {\n          return BPromise.resolve(null);\n        }\n      });\n  };\n\n  this.create = function (form, req) {\n    req = req || {};\n    var finalUserModel = userModel;\n    var newUserModel = config.getItem('userModel');\n    if(typeof newUserModel === 'object') {\n      var whitelist;\n      if(newUserModel.whitelist) {\n        whitelist = util.arrayUnion(userModel.whitelist, newUserModel.whitelist);\n      }\n      finalUserModel = extend(true, {}, userModel, config.getItem('userModel'));\n      finalUserModel.whitelist = whitelist || finalUserModel.whitelist;\n    }\n    var UserModel = new Model(finalUserModel);\n    var user = new UserModel(form);\n    var newUser;\n    return user.process()\n      .then(function (result) {\n        newUser = result;\n        if(emailUsername) {\n          newUser._id = newUser.email;\n        }\n        if(config.getItem('local.sendConfirmEmail')) {\n          newUser.unverifiedEmail = {\n            email: newUser.email,\n            token: util.URLSafeUUID()\n          };\n          delete newUser.email;\n        }\n        return util.hashPassword(newUser.password);\n      }, function(err) {\n        return BPromise.reject({error: 'Validation failed', validationErrors: err, status: 400});\n      })\n      .then(function (hash) {\n        // Store password hash\n        newUser.local = {};\n        newUser.local.salt = hash.salt;\n        newUser.local.derived_key = hash.derived_key;\n        delete newUser.password;\n        delete newUser.confirmPassword;\n        newUser.signUp = {\n          provider: 'local',\n          timestamp: new Date().toISOString(),\n          ip: req.ip\n        };\n        return addUserDBs(newUser);\n      })\n      .then(function(newUser) {\n        return self.logActivity(newUser._id, 'signup', 'local', req, newUser);\n      })\n      .then(function(newUser) {\n        return processTransformations(onCreateActions, newUser, 'local');\n      })\n      .then(function(finalNewUser) {\n        return userDB.put(finalNewUser);\n      })\n      .then(function(result) {\n        newUser._rev = result.rev;\n        if(!config.getItem('local.sendConfirmEmail')) {\n          return BPromise.resolve();\n        }\n        return mailer.sendEmail('confirmEmail', newUser.unverifiedEmail.email, {req: req, user: newUser});\n      })\n      .then(function () {\n        emitter.emit('signup', newUser, 'local');\n        return BPromise.resolve(newUser);\n      });\n  };\n\n  this.socialAuth = function(provider, auth, profile, req) {\n    var user;\n    var newAccount = false;\n    var action;\n    var baseUsername;\n    req = req || {};\n    var ip = req.ip;\n    // It is important that we return a Bluebird promise so oauth.js can call .nodeify()\n    return BPromise.resolve()\n      .then(function() {\n        return userDB.query('auth/' + provider, {key: profile.id, include_docs: true});\n      })\n      .then(function(results) {\n        if (results.rows.length > 0) {\n          user = results.rows[0].doc;\n          return BPromise.resolve();\n        } else {\n          newAccount = true;\n          user = {};\n          user[provider] = {};\n          if(profile.emails) {\n            user.email = profile.emails[0].value;\n          }\n          user.providers = [provider];\n          user.type = 'user';\n          user.roles = config.getItem('security.defaultRoles');\n          user.signUp = {\n            provider: provider,\n            timestamp: new Date().toISOString(),\n            ip: ip\n          };\n          var emailFail = function() {\n            return BPromise.reject({\n              error: 'Email already in use',\n              message: 'Your email is already in use. Try signing in first and then linking this account.',\n              status: 409\n            });\n          };\n          // Now we need to generate a username\n          if(emailUsername) {\n            if(!user.email) {\n              return BPromise.reject({\n                error: 'No email provided',\n                message: 'An email is required for registration, but ' + provider + 'didn\\'t supply one.',\n                status: 400\n              });\n            }\n            return self.validateEmailUsername(user.email)\n              .then(function(err) {\n                if(err) {\n                  return emailFail();\n                }\n                return BPromise.resolve(user.email.toLowerCase());\n              });\n          } else {\n            if(profile.username) {\n              baseUsername = profile.username.toLowerCase();\n            } else {\n              // If a username isn't specified we'll take it from the email\n              if(user.email) {\n                var parseEmail = user.email.split('@');\n                baseUsername = parseEmail[0].toLowerCase();\n              } else if(profile.displayName) {\n                baseUsername = profile.displayName.replace(/\\s/g, '').toLowerCase();\n              } else {\n                baseUsername = profile.id.toLowerCase();\n              }\n            }\n            return self.validateEmail(user.email)\n              .then(function(err) {\n                if(err) {\n                  return emailFail();\n                }\n                return generateUsername(baseUsername);\n              });\n          }\n        }\n      })\n      .then(function(finalUsername) {\n        if(finalUsername) {\n          user._id = finalUsername;\n        }\n        user[provider].auth = auth;\n        user[provider].profile = profile;\n        if(!user.name) {\n          user.name = profile.displayName;\n        }\n        delete user[provider].profile._raw;\n        if(newAccount) {\n          return addUserDBs(user);\n        } else {\n          return BPromise.resolve(user);\n        }\n      })\n      .then(function(userDoc) {\n        action = newAccount ? 'signup' : 'login';\n        return self.logActivity(userDoc._id, action, provider, req, userDoc);\n      })\n      .then(function(userDoc) {\n        if(newAccount) {\n          return processTransformations(onCreateActions, userDoc, provider);\n        } else {\n          return processTransformations(onLinkActions, userDoc, provider);\n        }\n      })\n      .then(function(finalUser) {\n        return userDB.put(finalUser);\n      })\n      .then(function() {\n        if(action === 'signup') {\n          emitter.emit('signup', user, provider);\n        }\n        return BPromise.resolve(user);\n      });\n  };\n\n  this.linkSocial = function(user_id, provider, auth, profile, req) {\n    req = req || {};\n    var user;\n    // Load user doc\n    return BPromise.resolve()\n      .then(function() {\n        return userDB.query('auth/' + provider, {key: profile.id});\n      })\n      .then(function(results) {\n        if(results.rows.length === 0) {\n          return BPromise.resolve();\n        } else {\n          if(results.rows[0].id !== user_id) {\n            return BPromise.reject({\n              error: 'Conflict',\n              message: 'This ' + provider + ' profile is already in use by another account.',\n              status: 409\n            });\n          }\n        }\n      })\n      .then(function() {\n        return userDB.get(user_id);\n      })\n      .then(function(theUser) {\n        user = theUser;\n        // Check for conflicting provider\n        if(user[provider] && (user[provider].profile.id !== profile.id)) {\n          return BPromise.reject({\n            error: 'Conflict',\n            message: 'Your account is already linked with another ' + provider + 'profile.',\n            status: 409\n          });\n        }\n        // Check email for conflict\n        if(!profile.emails) {\n          return BPromise.resolve({rows: []});\n        }\n        if(emailUsername) {\n          return userDB.query('auth/emailUsername', {key: profile.emails[0].value});\n        } else {\n          return userDB.query('auth/email', {key: profile.emails[0].value});\n        }\n      })\n      .then(function(results) {\n        var passed;\n        if(results.rows.length === 0) {\n          passed = true;\n        } else {\n          passed = true;\n          results.rows.forEach(function(row) {\n            if(row.id !== user_id) {\n              passed = false;\n            }\n          });\n        }\n        if(!passed) {\n          return BPromise.reject({\n            error: 'Conflict',\n            message: 'The email ' + profile.emails[0].value + ' is already in use by another account.',\n            status: 409\n          });\n        } else {\n          return BPromise.resolve();\n        }\n      })\n      .then(function() {\n        // Insert provider info\n        user[provider] = {};\n        user[provider].auth = auth;\n        user[provider].profile = profile;\n        if(!user.providers) {\n          user.providers = [];\n        }\n        if(user.providers.indexOf(provider) === -1) {\n          user.providers.push(provider);\n        }\n        if(!user.name) {\n          user.name = profile.displayName;\n        }\n        delete user[provider].profile._raw;\n        return self.logActivity(user._id, 'link', provider, req, user);\n      })\n      .then(function(userDoc) {\n        return processTransformations(onLinkActions, userDoc, provider);\n      })\n      .then(function(finalUser) {\n        return userDB.put(finalUser);\n      })\n      .then(function() {\n        return BPromise.resolve(user);\n      });\n  };\n\n  this.unlink = function(user_id, provider) {\n    var user;\n    return userDB.get(user_id)\n      .then(function(theUser) {\n        user = theUser;\n        if(!provider) {\n          return BPromise.reject({\n            error: 'Unlink failed',\n            message: 'You must specify a provider to unlink.',\n            status: 400\n          });\n        }\n        // We can only unlink if there are at least two providers\n        if(!user.providers || !(user.providers instanceof Array) || user.providers.length < 2) {\n          return BPromise.reject({\n            error: 'Unlink failed',\n            message: 'You can\\'t unlink your only provider!',\n            status: 400\n          });\n        }\n        // We cannot unlink local\n        if(provider === 'local') {\n          return BPromise.reject({\n            error: 'Unlink failed',\n            message: 'You can\\'t unlink local.',\n            status: 400\n          });\n        }\n        // Check that the provider exists\n        if(!user[provider] || typeof user[provider] !== 'object') {\n          return BPromise.reject({\n            error: 'Unlink failed',\n            message: 'Provider: ' + util.capitalizeFirstLetter(provider) + ' not found.',\n            status: 404\n          });\n        }\n        delete user[provider];\n        // Remove the unlinked provider from the list of providers\n        user.providers.splice(user.providers.indexOf(provider), 1);\n        return userDB.put(user);\n      })\n      .then(function() {\n        return BPromise.resolve(user);\n      });\n  };\n\n  this.createSession = function(user_id, provider, req) {\n    var user;\n    var newToken;\n    var newSession;\n    var password;\n    req = req || {};\n    var ip = req.ip;\n    return userDB.get(user_id)\n      .then(function(record) {\n        user = record;\n        return generateSession(user._id, user.roles);\n      })\n      .then(function(token) {\n        password = token.password;\n        newToken = token;\n        newToken.provider = provider;\n        return session.storeToken(newToken);\n      })\n      .then(function() {\n        return dbAuth.storeKey(user_id, newToken.key, password, newToken.expires, user.roles);\n      })\n      .then(function() {\n        // authorize the new session across all dbs\n        if(!user.personalDBs) {\n          return BPromise.resolve();\n        }\n        return dbAuth.authorizeUserSessions(user_id, user.personalDBs, newToken.key, user.roles);\n      })\n      .then(function() {\n        if(!user.session) {\n          user.session = {};\n        }\n         newSession = {\n          issued: newToken.issued,\n          expires: newToken.expires,\n          provider: provider,\n          ip: ip\n        };\n        user.session[newToken.key] = newSession;\n        // Clear any failed login attempts\n        if(provider === 'local') {\n          if(!user.local) user.local = {};\n          user.local.failedLoginAttempts = 0;\n          delete user.local.lockedUntil;\n        }\n        return self.logActivity(user._id, 'login', provider, req, user);\n      })\n      .then(function(userDoc) {\n        // Clean out expired sessions on login\n        return self.logoutUserSessions(userDoc, 'expired');\n      })\n      .then(function(finalUser) {\n        user = finalUser;\n        return userDB.put(finalUser);\n      })\n      .then(function() {\n        newSession.token = newToken.key;\n        newSession.password = password;\n        newSession.user_id = user._id;\n        newSession.roles = user.roles;\n        // Inject the list of userDBs\n        if(typeof user.personalDBs === 'object') {\n          var userDBs = {};\n          var publicURL;\n          if(config.getItem('dbServer.publicURL')) {\n            var dbObj = url.parse(config.getItem('dbServer.publicURL'));\n            dbObj.auth = newSession.token + ':' + newSession.password;\n            publicURL = dbObj.format();\n          } else {\n            publicURL = config.getItem('dbServer.protocol') + newSession.token + ':' + newSession.password + '@' +\n              config.getItem('dbServer.host') + '/';\n          }\n          Object.keys(user.personalDBs).forEach(function(finalDBName) {\n            userDBs[user.personalDBs[finalDBName].name] = publicURL + finalDBName;\n          });\n          newSession.userDBs = userDBs;\n        }\n        if(user.profile) {\n          newSession.profile = user.profile;\n        }\n        emitter.emit('login', newSession, provider);\n        return BPromise.resolve(newSession, provider);\n      });\n  };\n\n  this.handleFailedLogin = function(user, req) {\n    req = req || {};\n    var maxFailedLogins = config.getItem('security.maxFailedLogins');\n    if(!maxFailedLogins) {\n      return BPromise.resolve();\n    }\n    if(!user.local) {\n      user.local = {};\n    }\n    if(!user.local.failedLoginAttempts) {\n      user.local.failedLoginAttempts = 0;\n    }\n    user.local.failedLoginAttempts++;\n    if(user.local.failedLoginAttempts > maxFailedLogins) {\n      user.local.failedLoginAttempts = 0;\n      user.local.lockedUntil = Date.now() + config.getItem('security.lockoutTime') * 1000;\n    }\n    return self.logActivity(user._id, 'failed login', 'local', req, user)\n      .then(function(finalUser) {\n        return userDB.put(finalUser);\n      })\n      .then(function() {\n        return BPromise.resolve(!!user.local.lockedUntil);\n      });\n  };\n\n  this.logActivity = function(user_id, action, provider, req, userDoc, saveDoc) {\n    var logSize = config.getItem('security.userActivityLogSize');\n    if(!logSize) {\n      return BPromise.resolve(userDoc);\n    }\n    var promise;\n    if(userDoc) {\n      promise = BPromise.resolve(userDoc);\n    } else {\n      if(saveDoc !== false) {\n        saveDoc = true;\n      }\n      promise = userDB.get(user_id);\n    }\n    return promise\n      .then(function(theUser) {\n        userDoc = theUser;\n        if(!userDoc.activity || !(userDoc.activity instanceof Array)) {\n          userDoc.activity = [];\n        }\n        var entry = {\n          timestamp: new Date().toISOString(),\n          action: action,\n          provider: provider,\n          ip: req.ip\n        };\n        userDoc.activity.unshift(entry);\n        while(userDoc.activity.length > logSize) {\n          userDoc.activity.pop();\n        }\n        if(saveDoc) {\n          return userDB.put(userDoc)\n            .then(function() {\n              return BPromise.resolve(userDoc);\n            });\n        } else {\n          return BPromise.resolve(userDoc);\n        }\n      });\n  };\n\n  this.refreshSession = function (key) {\n    var newSession;\n    return session.fetchToken(key)\n      .then(function(oldToken) {\n        newSession = oldToken;\n        newSession.expires = Date.now() + sessionLife * 1000;\n        return BPromise.all([\n          userDB.get(newSession._id),\n          session.storeToken(newSession)\n        ]);\n      })\n      .then(function(results) {\n        var userDoc = results[0];\n        userDoc.session[key].expires = newSession.expires;\n        // Clean out expired sessions on refresh\n        return self.logoutUserSessions(userDoc, 'expired');\n      })\n      .then(function(finalUser) {\n        return userDB.put(finalUser);\n      })\n      .then(function() {\n        delete newSession.password;\n        newSession.token = newSession.key;\n        delete newSession.key;\n        newSession.user_id = newSession._id;\n        delete newSession._id;\n        delete newSession.salt;\n        delete newSession.derived_key;\n        emitter.emit('refresh', newSession);\n        return BPromise.resolve(newSession);\n      });\n  };\n\n  this.resetPassword = function (form, req) {\n    req = req || {};\n    var ResetPasswordModel = new Model(resetPasswordModel);\n    var passwordResetForm = new ResetPasswordModel(form);\n    var user;\n    return passwordResetForm.validate()\n      .then(function () {\n        return userDB.query('auth/passwordReset', {key: form.token, include_docs: true});\n      }, function(err) {\n        return BPromise.reject({\n          error: 'Validation failed',\n          validationErrors: err,\n          status: 400\n        });\n      })\n      .then(function (results) {\n        if (!results.rows.length) {\n          return BPromise.reject({status: 400, error: 'Invalid token'});\n        }\n        user = results.rows[0].doc;\n        if(user.forgotPassword.expires < Date.now()) {\n          return BPromise.reject({status: 400, error: 'Token expired'});\n        }\n        return util.hashPassword(form.password);\n      })\n      .then(function(hash) {\n        if(!user.local) {\n          user.local = {};\n        }\n        user.local.salt = hash.salt;\n        user.local.derived_key = hash.derived_key;\n        if(user.providers.indexOf('local') === -1) {\n          user.providers.push('local');\n        }\n        // logout user completely\n        return self.logoutUserSessions(user, 'all');\n      })\n      .then(function(userDoc) {\n        user = userDoc;\n        delete user.forgotPassword;\n        return self.logActivity(user._id, 'reset password', 'local', req, user);\n      })\n      .then(function(finalUser) {\n        return userDB.put(finalUser);\n      })\n      .then(function() {\n        emitter.emit('password-reset', user);\n        return BPromise.resolve(user);\n      });\n  };\n\n  this.changePasswordSecure = function(user_id, form, req) {\n    req = req || {};\n    var self = this;\n    var ChangePasswordModel = new Model(changePasswordModel);\n    var changePasswordForm = new ChangePasswordModel(form);\n    var user;\n    return changePasswordForm.validate()\n      .then(function () {\n        return userDB.get(user_id);\n      }, function(err) {\n        return BPromise.reject({error: 'Validation failed', validationErrors: err, status: 400});\n      })\n      .then(function() {\n        return userDB.get(user_id);\n      })\n      .then(function(userDoc) {\n        user = userDoc;\n        if(user.local && user.local.salt && user.local.derived_key) {\n          // Password is required\n          if(!form.currentPassword){\n            return BPromise.reject({error: 'Password change failed', message: 'You must supply your current password in order to change it.', status: 400});\n          }\n          return util.verifyPassword(user.local, form.currentPassword);\n        } else {\n          return BPromise.resolve();\n        }\n      })\n      .then(function() {\n        return self.changePassword(user._id, form.newPassword, user, req);\n      }, function(err) {\n        return BPromise.reject(err || {error: 'Password change failed', message: 'The current password you supplied is incorrect.', status: 400});\n      })\n      .then(function() {\n        if(req.user && req.user.key) {\n          return self.logoutOthers(req.user.key);\n        } else {\n          return BPromise.resolve();\n        }\n      });\n  };\n\n  this.changePassword = function(user_id, newPassword, userDoc, req) {\n    req = req || {};\n    var promise, user;\n    if (userDoc) {\n      promise = BPromise.resolve(userDoc);\n    } else {\n      promise = userDB.get(user_id);\n    }\n    return promise\n      .then(function(doc) {\n        user = doc;\n        return util.hashPassword(newPassword);\n      }, function(err) {\n        return BPromise.reject({\n          error: 'User not found',\n          status: 404\n        });\n      })\n      .then(function(hash) {\n        if(!user.local) {\n          user.local = {};\n        }\n        user.local.salt = hash.salt;\n        user.local.derived_key = hash.derived_key;\n        if(user.providers.indexOf('local') === -1) {\n          user.providers.push('local');\n        }\n        return self.logActivity(user._id, 'changed password', 'local', req, user);\n      })\n      .then(function(finalUser) {\n        return userDB.put(finalUser);\n      })\n      .then(function() {\n        emitter.emit('password-change', user);\n      });\n  };\n\n  this.forgotPassword = function(email, req) {\n    req = req || {};\n    var user, hash;\n    return userDB.query('auth/email', {key: email, include_docs: true})\n      .then(function(result) {\n        if(!result.rows.length) {\n          return BPromise.reject({\n            error: 'User not found',\n            status: 404\n          });\n        }\n        user = result.rows[0].doc;\n        hash = util.URLSafeUUID();\n        user.forgotPassword = {\n          token: hash,\n          issued: Date.now(),\n          expires: Date.now() + tokenLife * 1000\n        };\n        return self.logActivity(user._id, 'forgot password', 'local', req, user);\n      })\n      .then(function(finalUser) {\n        return userDB.put(finalUser);\n      })\n      .then(function() {\n        return mailer.sendEmail('forgotPassword', user.email || user.unverifiedEmail.email,\n          {user: user, req: req, token: user.forgotPassword.token});\n      }).then(function() {\n        emitter.emit('forgot-password', user);\n        return BPromise.resolve(user.forgotPassword);\n      });\n  };\n\n  this.verifyEmail = function(token, req) {\n    req = req || {};\n    var user;\n    return userDB.query('auth/verifyEmail', {key: token, include_docs: true})\n      .then(function(result) {\n        if(!result.rows.length) {\n          return BPromise.reject({error: 'Invalid token', status: 400});\n        }\n        user = result.rows[0].doc;\n        user.email = user.unverifiedEmail.email;\n        delete user.unverifiedEmail;\n        emitter.emit('email-verified', user);\n        return self.logActivity(user._id, 'verified email', 'local', req, user);\n      })\n      .then(function(finalUser) {\n        return userDB.put(finalUser);\n      });\n  };\n\n  this.changeEmail = function(user_id, newEmail, req) {\n    req = req || {};\n    if(!req.user) {\n      req.user = {provider: 'local'};\n    }\n    var user;\n    return self.validateEmail(newEmail)\n      .then(function(err) {\n        if(err) {\n          return BPromise.reject(err);\n        }\n        return userDB.get(user_id);\n      })\n      .then(function(userDoc) {\n        user = userDoc;\n        if(config.getItem('local.sendConfirmEmail')) {\n          user.unverifiedEmail = {\n            email: newEmail,\n            token: util.URLSafeUUID()\n          };\n          return mailer.sendEmail('confirmEmail', user.unverifiedEmail.email, {req: req, user: user});\n        } else {\n          user.email = newEmail;\n          return BPromise.resolve();\n        }\n      })\n      .then(function() {\n        emitter.emit('email-changed', user);\n        return self.logActivity(user._id, 'changed email', req.user.provider, req, user);\n      })\n      .then(function(finalUser) {\n        return userDB.put(finalUser);\n      });\n  };\n\n  this.addUserDB = function(user_id, dbName, type, designDocs, permissions) {\n    var userDoc;\n    var dbConfig = dbAuth.getDBConfig(dbName, type || 'private');\n    dbConfig.designDocs = designDocs || dbConfig.designDocs || '';\n    dbConfig.permissions = permissions || dbConfig.permissions;\n    return userDB.get(user_id)\n      .then(function(result) {\n        userDoc = result;\n        return dbAuth.addUserDB(userDoc, dbName, dbConfig.designDocs, dbConfig.type, dbConfig.permissions,\n          dbConfig.adminRoles, dbConfig.memberRoles);\n      })\n      .then(function(finalDBName) {\n        if(!userDoc.personalDBs) {\n          userDoc.personalDBs = {};\n        }\n        delete dbConfig.designDocs;\n        // If permissions is specified explicitly it will be saved, otherwise will be taken from defaults every session\n        if(!permissions) {\n          delete dbConfig.permissions;\n        }\n        delete dbConfig.adminRoles;\n        delete dbConfig.memberRoles;\n        userDoc.personalDBs[finalDBName] = dbConfig;\n        emitter.emit('user-db-added', user_id, dbName);\n        return userDB.put(userDoc);\n      });\n  };\n\n  this.removeUserDB = function(user_id, dbName, deletePrivate, deleteShared) {\n    var user;\n    var update = false;\n    return userDB.get(user_id)\n      .then(function(userDoc) {\n        user = userDoc;\n        if(user.personalDBs && typeof user.personalDBs === 'object') {\n          Object.keys(user.personalDBs).forEach(function(db) {\n            if(user.personalDBs[db].name === dbName) {\n              var type = user.personalDBs[db].type;\n              delete user.personalDBs[db];\n              update = true;\n              if(type === 'private' && deletePrivate) {\n                return dbAuth.removeDB(dbName);\n              }\n              if(type === 'shared' && deleteShared) {\n                return dbAuth.removeDB(dbName);\n              }\n            }\n          });\n        }\n        return BPromise.resolve();\n      })\n      .then(function() {\n        if(update) {\n          emitter.emit('user-db-removed', user_id, dbName);\n          return userDB.put(user);\n        }\n        return BPromise.resolve();\n      });\n  };\n\n  this.logoutUser = function(user_id, session_id) {\n    var promise, user;\n    if(user_id) {\n      promise = userDB.get(user_id);\n    } else {\n      if(!session_id) {\n        return BPromise.reject({\n          error: 'unauthorized',\n          message: 'Either user_id or session_id must be specified',\n          status: 401\n        });\n      }\n      promise = userDB.query('auth/session', {key: session_id, include_docs: true})\n        .then(function(results) {\n          if(!results.rows.length) {\n            return BPromise.reject({\n              error: 'unauthorized',\n              status: 401\n            });\n          }\n          return BPromise.resolve(results.rows[0].doc);\n        });\n    }\n    return promise\n      .then(function(record) {\n        user = record;\n        user_id = record._id;\n        return self.logoutUserSessions(user, 'all');\n      })\n      .then(function() {\n        emitter.emit('logout', user_id);\n        emitter.emit('logout-all', user_id);\n        return userDB.put(user);\n      });\n  };\n\n  this.logoutSession = function(session_id) {\n    var user;\n    var startSessions = 0;\n    var endSessions = 0;\n    return userDB.query('auth/session', {key: session_id, include_docs: true})\n      .then(function(results) {\n        if(!results.rows.length) {\n          return BPromise.reject({\n            error: 'unauthorized',\n            status: 401\n          });\n        }\n        user = results.rows[0].doc;\n        if(user.session) {\n          startSessions = Object.keys(user.session).length;\n          if(user.session[session_id]) {\n            delete user.session[session_id];\n          }\n        }\n        var promises = [];\n        promises.push(session.deleteTokens(session_id));\n        promises.push(dbAuth.removeKeys(session_id));\n        if(user) {\n          promises.push(dbAuth.deauthorizeUser(user, session_id));\n        }\n        return BPromise.all(promises);\n      })\n      .then(function() {\n        // Clean out expired sessions\n        return self.logoutUserSessions(user, 'expired');\n      })\n      .then(function(finalUser) {\n        user = finalUser;\n        if(user.session) {\n          endSessions = Object.keys(user.session).length;\n        }\n        emitter.emit('logout', user._id);\n        if(startSessions !== endSessions) {\n          return userDB.put(user);\n        } else {\n          return BPromise.resolve(false);\n        }\n      });\n  };\n\n  this.logoutOthers = function(session_id) {\n    var user;\n    return userDB.query('auth/session', {key: session_id, include_docs: true})\n      .then(function(results) {\n        if(results.rows.length) {\n          user = results.rows[0].doc;\n          if(user.session && user.session[session_id]) {\n            return self.logoutUserSessions(user, 'other', session_id);\n          }\n        }\n        return BPromise.resolve();\n      })\n      .then(function(finalUser) {\n        if(finalUser) {\n          return userDB.put(finalUser);\n        } else {\n          return BPromise.resolve(false);\n        }\n      });\n  };\n\n  this.logoutUserSessions = function(userDoc, op, currentSession) {\n    // When op is 'other' it will logout all sessions except for the specified 'currentSession'\n    var promises = [];\n    var sessions;\n    if(op === 'all' || op === 'other') {\n      sessions = util.getSessions(userDoc);\n    } else if(op === 'expired') {\n      sessions = util.getExpiredSessions(userDoc, Date.now());\n    }\n    if(op === 'other' && currentSession) {\n      // Remove the current session from the list of sessions we are going to delete\n      var index = sessions.indexOf(currentSession);\n      if(index > -1) {\n        sessions.splice(index, 1);\n      }\n    }\n    if(sessions.length) {\n      // Delete the sessions from our session store\n      promises.push(session.deleteTokens(sessions));\n      // Remove the keys from our couchDB auth database\n      promises.push(dbAuth.removeKeys(sessions));\n      // Deauthorize keys from each personal database\n      promises.push(dbAuth.deauthorizeUser(userDoc, sessions));\n      if(op === 'expired' || op === 'other') {\n        sessions.forEach(function(session) {\n          delete userDoc.session[session];\n        });\n      }\n    }\n    if(op ==='all') {\n      delete userDoc.session;\n    }\n    return BPromise.all(promises)\n      .then(function() {\n        return BPromise.resolve(userDoc);\n      });\n  };\n\n  this.remove = function(user_id, destroyDBs) {\n    var user;\n    var promises = [];\n    return userDB.get(user_id)\n      .then(function(userDoc) {\n        return self.logoutUserSessions(userDoc, 'all');\n      })\n      .then(function(userDoc) {\n        user = userDoc;\n        if(destroyDBs !== true || !user.personalDBs) {\n          return BPromise.resolve();\n        }\n        Object.keys(user.personalDBs).forEach(function(userdb) {\n          if(user.personalDBs[userdb].type === 'private') {\n            promises.push(dbAuth.removeDB(userdb));\n          }\n        });\n        return BPromise.all(promises);\n      })\n      .then(function() {\n        return userDB.remove(user);\n      });\n  };\n\n  this.removeExpiredKeys = dbAuth.removeExpiredKeys;\n\n  this.confirmSession = session.confirmToken;\n\n  this.quitRedis = session.quit;\n\n  function generateSession(username, roles) {\n    var getKey;\n    if(config.getItem('dbServer.cloudant')) {\n      getKey = require('./dbauth/cloudant').getAPIKey(userDB);\n    } else {\n      var token = util.URLSafeUUID();\n      // Make sure our token doesn't start with illegal characters\n      while(token[0] === '_' || token[0] === '-') {\n        token = util.URLSafeUUID();\n      }\n      getKey = BPromise.resolve({\n        key: token,\n        password: util.URLSafeUUID()\n      });\n    }\n    return getKey\n      .then(function(key) {\n        var now = Date.now();\n        return BPromise.resolve({\n          _id: username,\n          key: key.key,\n          password: key.password,\n          issued: now,\n          expires: now + sessionLife * 1000,\n          roles: roles\n        });\n      });\n  }\n\n  // Adds numbers to a base name until it finds a unique database key\n  function generateUsername(base) {\n    base = base.toLowerCase();\n    var entries = [];\n    var finalName;\n    return userDB.allDocs({startkey: base, endkey: base + '\\uffff', include_docs: false})\n      .then(function(results){\n        if(results.rows.length === 0) {\n          return BPromise.resolve(base);\n        }\n        for(var i=0; i<results.rows.length; i++) {\n          entries.push(results.rows[i].id);\n        }\n        if(entries.indexOf(base) === -1) {\n          return BPromise.resolve(base);\n        }\n        var num = 0;\n        while(!finalName) {\n          num++;\n          if(entries.indexOf(base+num) === -1) {\n            finalName = base + num;\n          }\n        }\n        return BPromise.resolve(finalName);\n      });\n  }\n\n  function addUserDBs(newUser) {\n    // Add personal DBs\n    if(!config.getItem('userDBs.defaultDBs')) {\n      return BPromise.resolve(newUser);\n    }\n    var promises = [];\n    newUser.personalDBs = {};\n\n    var processUserDBs = function(dbList, type) {\n      dbList.forEach(function(userDBName) {\n        var dbConfig = dbAuth.getDBConfig(userDBName);\n        promises.push(\n          dbAuth.addUserDB(newUser, userDBName, dbConfig.designDocs, type, dbConfig.permissions, dbConfig.adminRoles,\n            dbConfig.memberRoles)\n            .then(function(finalDBName) {\n              delete dbConfig.permissions;\n              delete dbConfig.adminRoles;\n              delete dbConfig.memberRoles;\n              delete dbConfig.designDocs;\n              dbConfig.type = type;\n              newUser.personalDBs[finalDBName] = dbConfig;\n            }));\n      });\n    };\n\n    // Just in case defaultDBs is not specified\n    var defaultPrivateDBs = config.getItem('userDBs.defaultDBs.private');\n    if(!Array.isArray(defaultPrivateDBs)) {\n      defaultPrivateDBs = [];\n    }\n    processUserDBs(defaultPrivateDBs, 'private');\n    var defaultSharedDBs = config.getItem('userDBs.defaultDBs.shared');\n    if(!Array.isArray(defaultSharedDBs)) {\n      defaultSharedDBs = [];\n    }\n    processUserDBs(defaultSharedDBs, 'shared');\n\n    return BPromise.all(promises).then(function() {\n      return BPromise.resolve(newUser);\n    });\n  }\n\n  return this;\n\n};\n","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/lib/session.js":"'use strict';\nvar BPromise = require('bluebird');\nvar redis = BPromise.promisifyAll(require('redis'));\nvar util = require('./util');\nvar extend = require('util')._extend;\n\nvar tokenPrefix = 'token';\n\nmodule.exports = function(config) {\n\n  var adapter;\n\n  if(config.getItem('session.adapter') === 'redis') {\n    adapter = new RedisAdapter(config);\n  } else {\n    adapter = new MemoryAdapter();\n  }\n\n  this.storeToken = function(token) {\n    token = extend({}, token);\n    if(!token.password && token.salt && token.derived_key) {\n      return adapter.storeKey(tokenPrefix + ':' + token.key, (token.expires - Date.now()), JSON.stringify(token))\n        .then(function() {\n          delete token.salt;\n          delete token.derived_key;\n          return BPromise.resolve(token);\n        });\n    }\n    return util.hashPassword(token.password)\n      .then(function(hash) {\n        token.salt = hash.salt;\n        token.derived_key = hash.derived_key;\n        delete token.password;\n        return adapter.storeKey(tokenPrefix + ':' + token.key, (token.expires - Date.now()), JSON.stringify(token));\n      })\n      .then(function() {\n        delete token.salt;\n        delete token.derived_key;\n        return BPromise.resolve(token);\n      });\n  };\n\n  this.deleteTokens = function(keys) {\n    var entries = [];\n    if(!(keys instanceof Array)) {\n      keys = [keys];\n    }\n    keys.forEach(function(key) {\n      entries.push(tokenPrefix + ':' + key);\n    });\n    return adapter.deleteKeys(entries);\n  };\n\n  this.confirmToken = function(key, password) {\n    var token;\n    return adapter.getKey(tokenPrefix + ':' + key)\n      .then(function(result) {\n        if(!result) {\n          return BPromise.reject('invalid token');\n        }\n        token = JSON.parse(result);\n        return util.verifyPassword(token, password);\n      })\n      .then(function() {\n        delete token.salt;\n        delete token.derived_key;\n        return BPromise.resolve(token);\n      }, function() {\n        return BPromise.reject('invalid token');\n      });\n  };\n\n  this.fetchToken = function(key) {\n    return adapter.getKey(tokenPrefix + ':' + key)\n      .then(function(result) {\n        return BPromise.resolve(JSON.parse(result));\n      });\n  };\n\n  this.quit = function() {\n    return adapter.quit();\n  };\n\n  return this;\n\n};\n\nvar RedisAdapter = function(config) {\n\n  var redisClient;\n\n  if(!config.getItem('session.redis.unix_socket')) {\n    if(config.getItem('session.redis.url')) {\n      redisClient = redis.createClient(config.getItem('session.redis.url'), config.getItem('session.redis.options'));\n    } else {\n      redisClient = redis.createClient(config.getItem('session.redis.port') || 6379,\n        config.getItem('session.redis.host') || '127.0.0.1', config.getItem('session.redis.options'));\n    }\n  } else {\n    redisClient = redis.createClient(config.getItem('session.redis.unix_socket'), config.getItem('session.redis.options'));\n  }\n\n  // Authenticate with Redis if necessary\n  if(config.getItem('session.redis.password')) {\n    redisClient.authAsync(config.getItem('session.redis.password'))\n      .catch(function(err) {\n        throw new Error(err);\n      });\n  }\n\n  redisClient.on('error', function (err) {\n    console.error('Redis error: ' + err);\n  });\n\n  redisClient.on('connect', function () {\n    console.log('Redis is ready');\n  });\n\n  this.storeKey = function(key, life, data) {\n    return redisClient.psetexAsync(key, life, data);\n  };\n\n  this.deleteKeys = function(keys) {\n    return redisClient.delAsync(keys);\n  };\n\n  this.getKey = function(key) {\n    return redisClient.getAsync(key);\n  };\n\n  this.quit = function() {\n    return redisClient.quit();\n  };\n\n  return this;\n\n};\n\nvar MemoryAdapter = function() {\n\n  var keys = {};\n  var expires = {};\n  console.log('Memory Adapter loaded');\n\n  this.storeKey = function(key, life, data) {\n    var now = Date.now();\n    keys[key] = data;\n    expires[key] = now + life;\n    removeExpired();\n    return BPromise.resolve();\n  };\n\n  this.getKey = function(key) {\n    var now = Date.now();\n    if(keys[key] && expires[key] > now) {\n      return BPromise.resolve(keys[key]);\n    } else {\n      return BPromise.resolve(false);\n    }\n  };\n\n  this.deleteKeys = function(keys) {\n    if(!(keys instanceof Array)) {\n      keys = [keys];\n    }\n    keys.forEach(function(key) {\n      delete keys[key];\n      delete expires[key];\n    });\n    removeExpired();\n    return BPromise.resolve(keys.length);\n  };\n\n  this.quit = function() {\n    return BPromise.resolve();\n  };\n\n  function removeExpired() {\n    var now = Date.now();\n    Object.keys(expires).forEach(function(key) {\n      if(expires[key] < now) {\n        delete keys[key];\n        delete expires[key];\n      }\n    });\n  }\n\n  return this;\n\n};","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/lib/dbauth/index.js":"'use strict';\nvar BPromise = require('bluebird');\nvar PouchDB = require('pouchdb');\nvar util = require('./../util');\nvar seed = require('pouchdb-seed-design');\nvar request = require('superagent');\n\nmodule.exports = function (config, userDB, couchAuthDB) {\n\n  var cloudant = config.getItem('dbServer.cloudant');\n\n  var adapter;\n\n  if(cloudant) {\n    adapter = require('./cloudant');\n  } else {\n    var CouchAdapter = require('./couchdb');\n    adapter = new CouchAdapter(couchAuthDB);\n  }\n\n  this.storeKey = function (username, key, password, expires, roles) {\n    return adapter.storeKey(username, key, password, expires, roles);\n  };\n\n  this.removeKeys = function(keys) {\n    return adapter.removeKeys(keys);\n  };\n\n  this.authorizeKeys = function (user_id, db, keys, permissions, roles) {\n    return adapter.authorizeKeys(user_id, db, keys, permissions, roles);\n  };\n\n  this.deauthorizeKeys = function (db, keys) {\n    return adapter.deauthorizeKeys(db, keys);\n  };\n\n  this.authorizeUserSessions = function(user_id, personalDBs, sessionKeys, roles) {\n    var self = this;\n    var promises = [];\n    sessionKeys = util.toArray(sessionKeys);\n    Object.keys(personalDBs).forEach(function(personalDB) {\n      var permissions = personalDBs[personalDB].permissions;\n      if(!permissions) {\n        permissions = config.getItem('userDBs.model.' + personalDBs[personalDB].name + '.permissions') || config.getItem('userDBs.model._default.permissions') || [];\n      }\n      var db = new PouchDB(util.getDBURL(config.getItem('dbServer')) + '/' + personalDB);\n      promises.push(self.authorizeKeys(user_id, db, sessionKeys, permissions, roles));\n    });\n    return BPromise.all(promises);\n  };\n\n  this.addUserDB = function (userDoc, dbName, designDocs, type, permissions, adminRoles, memberRoles) {\n    var self = this;\n    var promises = [];\n    adminRoles = adminRoles || [];\n    memberRoles = memberRoles || [];\n    // Create and the database and seed it if a designDoc is specified\n    var prefix = config.getItem('userDBs.privatePrefix') ? config.getItem('userDBs.privatePrefix') + '_' : '';\n    var finalDBName, newDB;\n    // Make sure we have a legal database name\n    var username = userDoc._id;\n    username = getLegalDBName(username);\n    if(type === 'shared') {\n      finalDBName = dbName;\n    } else {\n      finalDBName = prefix + dbName + '$' + username;\n    }\n    return self.createDB(finalDBName)\n      .then(function() {\n        newDB = new PouchDB(util.getDBURL(config.getItem('dbServer')) + '/' + finalDBName);\n        return adapter.initSecurity(newDB, adminRoles, memberRoles);\n      })\n      .then(function() {\n        // Seed the design docs\n        if (designDocs && designDocs instanceof Array) {\n          designDocs.forEach(function(ddName) {\n            var dDoc = self.getDesignDoc(ddName);\n            if(dDoc) {\n              promises.push(seed(newDB, dDoc));\n            } else {\n              console.warn('Failed to locate design doc: ' + ddName);\n            }\n          });\n        }\n        // Authorize the user's existing DB keys to access the new database\n        var keysToAuthorize = [];\n        if (userDoc.session) {\n          for (var key in userDoc.session) {\n            if(userDoc.session.hasOwnProperty(key) && userDoc.session[key].expires > Date.now()) {\n              keysToAuthorize.push(key);\n            }\n          }\n        }\n        if (keysToAuthorize.length > 0) {\n          promises.push(self.authorizeKeys(userDoc._id, newDB, keysToAuthorize, permissions, userDoc.roles));\n        }\n        return BPromise.all(promises);\n      })\n      .then(function() {\n        return BPromise.resolve(finalDBName);\n      });\n  };\n\n  this.removeExpiredKeys = function () {\n    var self = this;\n    var keysByUser = {};\n    var userDocs = {};\n    var expiredKeys = [];\n    // query a list of expired keys by user\n    return userDB.query('auth/expiredKeys', {endkey: Date.now(), include_docs: true})\n      .then(function(results) {\n        // group by user\n        results.rows.forEach(function(row) {\n          keysByUser[row.value.user] = row.value.key;\n          expiredKeys.push(row.value.key);\n          // Add the user doc if it doesn't already exist\n          if(typeof userDocs[row.value.user] === 'undefined') {\n            userDocs[row.value.user] = row.doc;\n          }\n          // remove each key from user.session\n          if(userDocs[row.value.user].session) {\n            Object.keys(userDocs[row.value.user].session).forEach(function(session) {\n              if(row.value.key === session) {\n                delete userDocs[row.value.user].session[session];\n              }\n            });\n          }\n        });\n        return self.removeKeys(expiredKeys);\n      })\n      .then(function() {\n        // - deauthorize keys for each personal database of each user\n        var deauthorize = [];\n        Object.keys(keysByUser).forEach(function(user) {\n          deauthorize.push(self.deauthorizeUser(userDocs[user], keysByUser[user]));\n        });\n        return BPromise.all(deauthorize);\n      })\n      .then(function() {\n        var userUpdates = [];\n        Object.keys(userDocs).forEach(function(user) {\n          userUpdates.push(userDocs[user]);\n        });\n        // Bulk save user doc updates\n        return userDB.bulkDocs(userUpdates);\n      })\n      .then(function() {\n        return BPromise.resolve(expiredKeys);\n      });\n  };\n\n  this.deauthorizeUser = function(userDoc, keys) {\n    var self = this;\n    var promises = [];\n    // If keys is not specified we will deauthorize all of the users sessions\n    if(!keys) {\n      keys = util.getSessions(userDoc);\n    }\n    keys = util.toArray(keys);\n    if(userDoc.personalDBs && typeof userDoc.personalDBs === 'object') {\n      Object.keys(userDoc.personalDBs).forEach(function(personalDB) {\n        var db = new PouchDB(util.getDBURL(config.getItem('dbServer')) + '/' + personalDB);\n        promises.push(self.deauthorizeKeys(db, keys));\n      });\n      return BPromise.all(promises);\n    } else {\n      return BPromise.resolve(false);\n    }\n  };\n\n  this.getDesignDoc = function(docName) {\n    if(!docName) {\n      return null;\n    }\n    var designDoc;\n    var designDocDir = config.getItem('userDBs.designDocDir');\n    if(!designDocDir) {\n      designDocDir = __dirname;\n    }\n    try {\n      designDoc = require(designDocDir + '/' + docName);\n    }\n    catch(err) {\n      console.warn('Design doc: ' + designDocDir + '/' + docName + ' not found.');\n      designDoc = null;\n    }\n    return designDoc;\n  };\n\n  this.getDBConfig = function(dbName, type) {\n    var dbConfig = {\n      name: dbName\n    };\n    dbConfig.adminRoles = config.getItem('userDBs.defaultSecurityRoles.admins') || [];\n    dbConfig.memberRoles = config.getItem('userDBs.defaultSecurityRoles.members') || [];\n    var dbConfigRef = 'userDBs.model.' + dbName;\n    if(config.getItem(dbConfigRef)) {\n      dbConfig.permissions = config.getItem(dbConfigRef + '.permissions') || [];\n      dbConfig.designDocs = config.getItem(dbConfigRef + '.designDocs') || [];\n      dbConfig.type = type || config.getItem(dbConfigRef + '.type') || 'private';\n      var dbAdminRoles = config.getItem(dbConfigRef + '.adminRoles');\n      var dbMemberRoles = config.getItem(dbConfigRef + '.memberRoles');\n      if(dbAdminRoles && dbAdminRoles instanceof Array) {\n        dbAdminRoles.forEach(function(role) {\n          if(role && dbConfig.adminRoles.indexOf(role) === -1) {\n            dbConfig.adminRoles.push(role);\n          }\n        });\n      }\n      if(dbMemberRoles && dbMemberRoles instanceof Array) {\n        dbMemberRoles.forEach(function(role) {\n          if(role && dbConfig.memberRoles.indexOf(role) === -1) {\n            dbConfig.memberRoles.push(role);\n          }\n        });\n      }\n    } else if(config.getItem('userDBs.model._default')) {\n      dbConfig.permissions = config.getItem('userDBs.model._default.permissions') || [];\n      // Only add the default design doc to a private database\n      if(!type || type === 'private') {\n        dbConfig.designDocs = config.getItem('userDBs.model._default.designDocs') || [];\n      } else {\n        dbConfig.designDocs = [];\n      }\n      dbConfig.type = type || 'private';\n    } else {\n      dbConfig.type = type || 'private';\n    }\n    return dbConfig;\n  };\n\n  this.createDB = function (dbName) {\n    var finalUrl = util.getDBURL(config.getItem('dbServer')) + '/' + dbName;\n    return BPromise.fromNode(function(callback) {\n      request.put(finalUrl)\n        .send({})\n        .end(callback);\n    })\n      .then(function(res) {\n        return BPromise.resolve(JSON.parse(res.text));\n      }, function(err) {\n        if(err.status === 412) {\n          return BPromise.resolve(false);\n        } else {\n          return BPromise.reject(err.text);\n        }\n      });\n  };\n\n  this.removeDB = function(dbName) {\n    var db = new PouchDB(util.getDBURL(config.getItem('dbServer')) + '/' + dbName);\n    return db.destroy();\n  };\n\n\n  return this;\n};\n\n// Escapes any characters that are illegal in a CouchDB database name using percent codes inside parenthesis\n// Example: 'My.name@example.com' => 'my(2e)name(40)example(2e)com'\nfunction getLegalDBName(input) {\n  input = input.toLowerCase();\n  var output = encodeURIComponent(input);\n  output = output.replace(/\\./g, '%2E');\n  output = output.replace(/!/g, '%21');\n  output = output.replace(/~/g, '%7E');\n  output = output.replace(/\\*/g, '%2A');\n  output = output.replace(/'/g, '%27');\n  output = output.replace(/\\(/g, '%28');\n  output = output.replace(/\\)/g, '%29');\n  output = output.replace(/\\-/g, '%2D');\n  output = output.toLowerCase();\n  output = output.replace(/(%..)/g, function(esc) {\n    esc = esc.substr(1);\n    return '(' + esc + ')';\n  });\n  return output;\n}\n","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/lib/oauth.js":"'use strict';\nvar fs = require('fs');\nvar path = require('path');\nvar BPromise = require('bluebird');\nvar ejs  = require('ejs');\nvar extend = require('util')._extend;\nvar util = require('./util');\n\nvar stateRequired = ['google', 'linkedin'];\n\nmodule.exports = function(router, passport, user, config) {\n\n  // Function to initialize a session following authentication from a socialAuth provider\n  function initSession(req, res, next) {\n    var provider = getProvider(req.path);\n    return user.createSession(req.user._id, provider, req)\n      .then(function(mySession) {\n        return BPromise.resolve({\n          error: null,\n          session: mySession,\n          link: null\n        });\n      })\n      .then(function (results) {\n        var template;\n        if(config.getItem('testMode.oauthTest')) {\n          template = fs.readFileSync(path.join(__dirname, '../templates/oauth/auth-callback-test.ejs'), 'utf8');\n        } else {\n          template = fs.readFileSync(path.join(__dirname, '../templates/oauth/auth-callback.ejs'), 'utf8');\n        }\n        var html = ejs.render(template, results);\n        res.status(200).send(html);\n      }, function (err) {\n        return next(err);\n      });\n  }\n\n  // Function to initialize a session following authentication from a socialAuth provider\n  function initTokenSession(req, res, next) {\n    var provider = getProviderToken(req.path);\n    return user.createSession(req.user._id, provider, req)\n      .then(function(mySession) {\n        return BPromise.resolve(mySession);\n      })\n      .then(function (session) {\n        res.status(200).json(session);\n      }, function (err) {\n        return next(err);\n      });\n  }\n\n  // Called after an account has been succesfully linked\n  function linkSuccess(req, res, next) {\n    var provider = getProvider(req.path);\n    var result = {\n      error: null,\n      session: null,\n      link: provider\n    };\n    var template;\n    if(config.getItem('testMode.oauthTest')) {\n      template = fs.readFileSync(path.join(__dirname, '../templates/oauth/auth-callback-test.ejs'), 'utf8');\n    } else {\n      template = fs.readFileSync(path.join(__dirname, '../templates/oauth/auth-callback.ejs'), 'utf8');\n    }\n    var html = ejs.render(template, result);\n    res.status(200).send(html);\n  }\n\n  // Called after an account has been succesfully linked using access_token provider\n  function linkTokenSuccess(req, res, next) {\n    var provider = getProviderToken(req.path);\n    res.status(200).json({\n      ok: true,\n      success: util.capitalizeFirstLetter(provider) + ' successfully linked',\n      provider: provider\n    });\n  }\n\n  // Handles errors if authentication fails\n  function oauthErrorHandler(err,req,res,next) {\n    var template;\n    if(config.getItem('testMode.oauthTest')) {\n      template = fs.readFileSync(path.join(__dirname, '../templates/oauth/auth-callback-test.ejs'), 'utf8');\n    } else {\n      template = fs.readFileSync(path.join(__dirname, '../templates/oauth/auth-callback.ejs'), 'utf8');\n    }\n    var html = ejs.render(template, {error: err.message, session: null, link: null});\n    console.error(err);\n    if(err.stack) {\n      console.error(err.stack);\n    }\n    res.status(400).send(html);\n  }\n\n  // Handles errors if authentication from access_token provider fails\n  function tokenAuthErrorHandler(err,req,res,next) {\n    var status;\n    if(req.user && req.user._id) {\n      status = 403;\n    } else {\n      status = 401;\n    }\n    console.error(err);\n    if(err.stack) {\n      console.error(err.stack);\n      delete err.stack;\n    }\n    res.status(status).json(err);\n  }\n\n  // Framework to register OAuth providers with passport\n  function registerProvider(provider, configFunction) {\n    provider = provider.toLowerCase();\n    var configRef = 'providers.' + provider;\n    if (config.getItem(configRef + '.credentials')) {\n      var credentials = config.getItem(configRef + '.credentials');\n      credentials.passReqToCallback = true;\n      var options = config.getItem(configRef + '.options') || {};\n      configFunction.call(null, credentials, passport, authHandler);\n      router.get('/' + provider, passportCallback(provider, options, 'login'));\n      router.get('/' + provider + '/callback', passportCallback(provider, options, 'login'), initSession, oauthErrorHandler);\n      if(!config.getItem('security.disableLinkAccounts')) {\n        router.get('/link/' + provider, passport.authenticate('bearer', {session: false}), passportCallback(provider, options, 'link'));\n        router.get('/link/' + provider + '/callback', passport.authenticate('bearer', {session: false}),\n          passportCallback(provider, options, 'link'), linkSuccess, oauthErrorHandler);\n      }\n      console.log(provider + ' loaded.');\n    }\n  }\n\n  // A shortcut to register OAuth2 providers that follow the exact accessToken, refreshToken pattern.\n  function registerOAuth2 (providerName, Strategy) {\n    registerProvider(providerName, function (credentials, passport, authHandler) {\n      passport.use(new Strategy(credentials,\n        function (req, accessToken, refreshToken, profile, done) {\n          authHandler(req, providerName, {accessToken: accessToken, refreshToken: refreshToken}, profile)\n            .asCallback(done);\n        }\n      ));\n    });\n  }\n\n  // Registers a provider that accepts an access_token directly from the client, skipping the popup window and callback\n  // This is for supporting Cordova, native IOS and Android apps, as well as other devices\n  function registerTokenProvider (providerName, Strategy) {\n    providerName = providerName.toLowerCase();\n    var configRef = 'providers.' + providerName;\n    if (config.getItem(configRef + '.credentials')) {\n      var credentials = config.getItem(configRef + '.credentials');\n      credentials.passReqToCallback = true;\n      var options = config.getItem(configRef + '.options') || {};\n      // Configure the Passport Strategy\n      passport.use(providerName + '-token', new Strategy(credentials,\n        function (req, accessToken, refreshToken, profile, done) {\n          authHandler(req, providerName, {accessToken: accessToken, refreshToken: refreshToken}, profile)\n            .asCallback(done);\n        }));\n      router.post('/' + providerName + '/token', passportTokenCallback(providerName, options), initTokenSession, tokenAuthErrorHandler);\n      if(!config.getItem('security.disableLinkAccounts')) {\n        router.post('/link/' + providerName + '/token', passport.authenticate('bearer', {session: false}),\n          passportTokenCallback(providerName, options), linkTokenSuccess, tokenAuthErrorHandler);\n      }\n      console.log(providerName + '-token loaded.');\n    }\n  }\n\n  // This is called after a user has successfully authenticated with a provider\n  // If a user is authenticated with a bearer token we will link an account, otherwise log in\n  // auth is an object containing 'access_token' and optionally 'refresh_token'\n  function authHandler(req, provider, auth, profile) {\n    if(req.user && req.user._id && req.user.key) {\n      return user.linkSocial(req.user._id, provider, auth, profile, req);\n    } else {\n      return user.socialAuth(provider, auth, profile, req);\n    }\n  }\n\n  // Configures the passport.authenticate for the given provider, passing in options\n  // Operation is 'login' or 'link'\n  function passportCallback(provider, options, operation) {\n    return function(req, res, next) {\n      var theOptions = extend({}, options);\n      if(provider === 'linkedin') {\n        theOptions.state = true;\n      }\n      var accessToken = req.query.bearer_token || req.query.state;\n      if(accessToken && (stateRequired.indexOf(provider) > -1 || config.getItem('providers.' + provider + '.stateRequired') === true)) {\n        theOptions.state = accessToken;\n      }\n      theOptions.callbackURL = getLinkCallbackURLs(provider, req, operation, accessToken);\n      theOptions.session = false;\n      passport.authenticate(provider, theOptions)(req, res, next);\n    };\n  }\n\n  // Configures the passport.authenticate for the given access_token provider, passing in options\n  function passportTokenCallback(provider, options) {\n    return function(req, res, next) {\n      var theOptions = extend({}, options);\n      theOptions.session = false;\n      passport.authenticate(provider + '-token', theOptions)(req, res, next);\n    };\n  }\n\n  function getLinkCallbackURLs(provider, req, operation, accessToken) {\n    if(accessToken) {\n      accessToken = encodeURIComponent(accessToken);\n    }\n    var protocol = (req.get('X-Forwarded-Proto') || req.protocol) + '://';\n    if(operation === 'login') {\n      return protocol + req.get('host') + req.baseUrl + '/' + provider + '/callback';\n    }\n    if(operation === 'link') {\n      var reqUrl;\n      if(accessToken && (stateRequired.indexOf(provider) > -1 || config.getItem('providers.' + provider + '.stateRequired') === true)) {\n        reqUrl = protocol + req.get('host') + req.baseUrl + '/link/' + provider + '/callback';\n      } else {\n        reqUrl = protocol + req.get('host') + req.baseUrl + '/link/' + provider + '/callback?state=' + accessToken;\n      }\n      return reqUrl;\n    }\n  }\n\n  // Gets the provider name from a callback path\n  function getProvider(pathname) {\n    var items = pathname.split('/');\n    var index = items.indexOf('callback');\n    if(index > 0) {\n      return items[index-1];\n    }\n  }\n\n  // Gets the provider name from a callback path for access_token strategy\n  function getProviderToken(pathname) {\n    var items = pathname.split('/');\n    var index = items.indexOf('token');\n    if(index > 0) {\n      return items[index-1];\n    }\n  }\n\n  return {\n    registerProvider: registerProvider,\n    registerOAuth2: registerOAuth2,\n    registerTokenProvider: registerTokenProvider\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/lib/routes.js":"'use strict';\nvar util = require('./util');\n\nmodule.exports = function(config, router, passport, user) {\n\n  var env = process.env.NODE_ENV || 'development';\n\n  router.post('/login', function(req, res, next) {\n    passport.authenticate('local', function(err, user, info) {\n      if(err) {\n        return next(err);\n      }\n      if(!user) {\n        // Authentication failed\n        return res.status(401).json(info);\n      }\n      // Success\n      req.logIn(user, {session: false}, function(err) {\n        if (err) {\n          return next(err);\n        }\n      });\n      return next();\n    })(req, res, next);\n    }, function (req, res, next) {\n      // Success handler\n      return user.createSession(req.user._id, 'local', req)\n        .then(function (mySession) {\n          res.status(200).json(mySession);\n        }, function (err) {\n          return next(err);\n        });\n    });\n\n  router.post('/refresh',\n    passport.authenticate('bearer', {session: false}),\n    function (req, res, next) {\n      return user.refreshSession(req.user.key)\n        .then(function (mySession) {\n          res.status(200).json(mySession);\n        }, function (err) {\n          return next(err);\n        });\n    });\n\n  router.post('/logout',\n    function (req, res, next) {\n      var sessionToken = util.getSessionToken(req);\n      if(!sessionToken) {\n        return next({\n          error: 'unauthorized',\n          status: 401\n        });\n      }\n      user.logoutSession(sessionToken)\n        .then(function () {\n          res.status(200).json({ok: true, success: 'Logged out'});\n        }, function (err) {\n          console.error('Logout failed');\n          return next(err);\n        });\n    });\n\n  router.post('/logout-others',\n    passport.authenticate('bearer', {session: false}),\n    function (req, res, next) {\n      user.logoutOthers(req.user.key)\n        .then(function () {\n          res.status(200).json({success: 'Other sessions logged out'});\n        }, function (err) {\n          console.error('Logout failed');\n          return next(err);\n        });\n    });\n\n  router.post('/logout-all',\n    function (req, res, next) {\n      var sessionToken = util.getSessionToken(req);\n      if(!sessionToken) {\n        return next({\n          error: 'unauthorized',\n          status: 401\n        });\n      }\n      user.logoutUser(null, sessionToken)\n        .then(function () {\n          res.status(200).json({success: 'Logged out'});\n        }, function (err) {\n          console.error('Logout-all failed');\n          return next(err);\n        });\n    });\n\n  // Setting up the auth api\n  router.post('/register', function (req, res, next) {\n      user.create(req.body, req)\n        .then(function (newUser) {\n          if(config.getItem('security.loginOnRegistration')) {\n            return user.createSession(newUser._id, 'local', req.ip)\n              .then(function (mySession) {\n                res.status(200).json(mySession);\n              }, function (err) {\n                return next(err);\n              });\n          } else {\n            res.status(201).json({success: 'User created.'});\n          }\n        }, function (err) {\n          return next(err);\n        });\n    });\n\n  router.post('/forgot-password', function (req, res, next) {\n      user.forgotPassword(req.body.email, req).then(function () {\n        res.status(200).json({success: 'Password recovery email sent.'});\n      }, function (err) {\n        return next(err);\n      });\n    });\n\n  router.post('/password-reset', function (req, res, next) {\n      user.resetPassword(req.body, req)\n        .then(function (user) {\n          if(config.getItem('security.loginOnPasswordReset')) {\n            return user.createSession(user._id, 'local', req.ip)\n              .then(function (mySession) {\n                res.status(200).json(mySession);\n              }, function (err) {\n                return next(err);\n              });\n          } else {\n            res.status(200).json({success: 'Password successfully reset.'});\n          }\n        }, function (err) {\n          return next(err);\n        });\n    });\n\n  router.post('/password-change',\n    passport.authenticate('bearer', {session: false}),\n    function (req, res, next) {\n      user.changePasswordSecure(req.user._id, req.body, req)\n        .then(function () {\n          res.status(200).json({success: 'password changed'});\n        }, function (err) {\n          return next(err);\n        });\n    });\n\n  router.post('/unlink/:provider',\n    passport.authenticate('bearer', {session: false}),\n    function(req, res, next) {\n      var provider = req.params.provider;\n      user.unlink(req.user._id, provider)\n        .then(function() {\n          res.status(200).json({success: util.capitalizeFirstLetter(provider) + ' unlinked'});\n        }, function (err) {\n          return next(err);\n        });\n    });\n\n  router.get('/confirm-email/:token', function (req, res, next) {\n    var redirectURL = config.getItem('local.confirmEmailRedirectURL');\n    if (!req.params.token) {\n      var err = {error: 'Email verification token required'};\n      if(redirectURL) {\n        return res.status(201).redirect(redirectURL + '?error=' + encodeURIComponent(err.error));\n      }\n      return res.status(400).send(err);\n    }\n    user.verifyEmail(req.params.token, req).then(function () {\n      if(redirectURL) {\n        return res.status(201).redirect(redirectURL + '?success=true');\n      }\n      res.status(200).send({ok: true, success: 'Email verified'});\n    }, function (err) {\n      if(redirectURL) {\n        var query = '?error=' + encodeURIComponent(err.error);\n        if(err.message) {\n          query += '&message=' + encodeURIComponent(err.message);\n        }\n        return res.status(201).redirect(redirectURL + query);\n      }\n      return next(err);\n    });\n  });\n\n  router.get('/validate-username/:username',\n    function(req, res, next) {\n      if(!req.params.username) {\n        return next({error: 'Username required', status: 400});\n      }\n      user.validateUsername(req.params.username)\n        .then(function(err) {\n          if(!err) {\n            res.status(200).json({ok: true});\n          } else {\n            res.status(409).json({error: 'Username already in use'});\n          }\n        }, function(err) {\n          return next(err);\n        });\n    }\n  );\n\n  router.get('/validate-email/:email',\n    function(req, res, next) {\n      var promise;\n      if(!req.params.email) {\n        return next({error: 'Email required', status: 400});\n      }\n      if(config.getItem('local.emailUsername')) {\n        promise = user.validateEmailUsername(req.params.email);\n      } else {\n        promise = user.validateEmail(req.params.email);\n      }\n      promise\n        .then(function(err) {\n          if(!err) {\n            res.status(200).json({ok: true});\n          } else {\n            res.status(409).json({error: 'Email already in use'});\n          }\n        }, function(err) {\n          return next(err);\n        });\n    }\n  );\n\n  router.post('/change-email',\n    passport.authenticate('bearer', {session: false}),\n    function (req, res, next) {\n      user.changeEmail(req.user._id, req.body.newEmail, req)\n        .then(function () {\n          res.status(200).json({ok: true, success: 'Email changed'});\n        }, function (err) {\n          return next(err);\n        });\n    });\n\n  // route to test token authentication\n  router.get('/session',\n    passport.authenticate('bearer', {session: false}),\n    function (req, res) {\n      var user = req.user;\n      user.user_id = user._id;\n      delete user._id;\n      // user.token = user.key;\n      delete user.key;\n      res.status(200).json(user);\n    });\n\n  // Error handling\n  router.use(function(err, req, res, next) {\n    console.error(err);\n    if(err.stack) {\n      console.error(err.stack);\n    }\n    res.status(err.status || 500);\n    if(err.stack && env !== 'development') {\n      delete err.stack;\n    }\n    res.json(err);\n  });\n\n};\n","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/lib/local.js":"'use strict';\nvar util = require('./util');\nvar LocalStrategy = require('passport-local');\nvar BearerStrategy = require('passport-http-bearer-sl').Strategy;\n\n\nmodule.exports = function (config, passport, user) {\n\n  // API token strategy\n  passport.use(new BearerStrategy(\n    function (tokenPass, done) {\n      var parse = tokenPass.split(':');\n      if(parse.length < 2) {\n        done(null, false, {message: 'invalid token'});\n      }\n      var token = parse[0];\n      var password = parse[1];\n      user.confirmSession(token, password)\n        .then(function (theuser) {\n          done(null, theuser);\n        }, function (err) {\n          if (err instanceof Error) {\n            done(err, false);\n          } else {\n            done(null, false, {message: err});\n          }\n        });\n    }\n  ));\n\n  // Use local strategy\n  passport.use(new LocalStrategy({\n      usernameField: config.getItem('local.usernameField') || 'username',\n      passwordField: config.getItem('local.passwordField') || 'password',\n      session: false,\n      passReqToCallback: true\n    },\n    function (req, username, password, done) {\n      user.get(username)\n        .then(function (theuser) {\n          if (theuser) {\n            // Check if the account is locked\n            if(theuser.local && theuser.local.lockedUntil && theuser.local.lockedUntil > Date.now()) {\n              return done(null, false, {\n                error: 'Unauthorized',\n                message: 'Your account is currently locked. Please wait a few minutes and try again.'\n              });\n            }\n            if(!theuser.local || !theuser.local.derived_key) {\n              return done(null, false, {\n                error: 'Unauthorized',\n                message: 'Invalid username or password'\n              });\n            }\n            util.verifyPassword(theuser.local, password)\n              .then(function () {\n                // Check if the email has been confirmed if it is required\n                if(config.getItem('local.requireEmailConfirm') && !theuser.email) {\n                  return done(null, false, {\n                    error: 'Unauthorized',\n                    message: 'You must confirm your email address.'\n                  });\n                }\n                // Success!!!\n                return done(null, theuser);\n              }, function (err) {\n                if (!err) {\n                  // Password didn't authenticate\n                  return handleFailedLogin(theuser, req, done);\n                } else {\n                  // Hashing function threw an error\n                  return done(err);\n                }\n              });\n          } else {\n            // user not found\n            return done(null, false, {\n              error: 'Unauthorized',\n              message: 'Invalid username or password'\n            });\n          }\n        }, function (err) {\n          // Database threw an error\n          return done(err);\n        });\n    }\n  ));\n\n  function handleFailedLogin(userDoc, req, done) {\n    var invalid = {\n      error: 'Unauthorized',\n      message: 'Invalid username or password'\n    };\n    return user.handleFailedLogin(userDoc, req)\n      .then(function(locked) {\n        if(locked) {\n          invalid.message = 'Maximum failed login attempts exceeded. Your account has been locked for ' +\n              Math.round(config.getItem('security.lockoutTime') / 60) + ' minutes.';\n        }\n        return done(null, false, invalid);\n      });\n  }\n\n};\n\n","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/lib/middleware.js":"// Contains middleware useful for securing your routes\n'use strict';\nmodule.exports = function(passport) {\n\n  var forbiddenError = {\n    error: 'Forbidden',\n    message: 'You do not have permission to access this resource.',\n    status: 403\n  };\n\n  var superloginError = {\n    error: 'superlogin',\n    message: 'requireAuth must be used before checking roles',\n    status: 500\n  };\n\n  // Requires that the user be authenticated with a bearer token\n  function requireAuth(req, res, next) {\n    passport.authenticate('bearer', {session: false})(req, res, next);\n  }\n\n  // Requires that the user have the specified role\n  function requireRole(requiredRole) {\n    return function(req, res, next) {\n      if(!req.user) {\n        return next(superloginError);\n      }\n      var roles = req.user.roles;\n      if(!roles || !roles.length || roles.indexOf(requiredRole) === -1) {\n        res.status(forbiddenError.status);\n        res.json(forbiddenError);\n      } else {\n        next();\n      }\n    };\n  }\n\n  // Requires that the user have at least one of the specified roles\n  function requireAnyRole(possibleRoles) {\n    return function(req, res, next) {\n      if(!req.user) {\n        return next(superloginError);\n      }\n      var denied = true;\n      var roles = req.user.roles;\n      if (roles && roles.length) {\n        for (var i = 0; i < possibleRoles.length; i++) {\n          if (roles.indexOf(possibleRoles[i]) !== -1) {\n            denied = false;\n          }\n        }\n      }\n      if(denied) {\n        res.status(forbiddenError.status);\n        res.json(forbiddenError);\n      } else {\n        next();\n      }\n    };\n  }\n\n  function requireAllRoles(requiredRoles) {\n    return function(req, res, next) {\n      if(!req.user) {\n        return next(superloginError);\n      }\n      var denied = false;\n      var roles = req.user.roles;\n      if (!roles || !roles.length) {\n        denied = true;\n      } else {\n        for (var i = 0; i < requiredRoles.length; i++) {\n          if (roles.indexOf(requiredRoles[i]) === -1) {\n            denied = true;\n          }\n        }\n      }\n      if(denied) {\n        res.status(forbiddenError.status);\n        res.json(forbiddenError);\n      } else {\n        next();\n      }\n    };\n  }\n\n  return {\n    requireAuth: requireAuth,\n    requireRole: requireRole,\n    requireAnyRole: requireAnyRole,\n    requireAllRoles: requireAllRoles\n  };\n\n};\n\n","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/lib/mailer.js":"'use strict';\nvar fs = require('fs');\nvar BPromise = require('bluebird');\nvar nodemailer = require('nodemailer');\nvar ejs = require('ejs');\n\nmodule.exports = function(config) {\n\n  // Initialize the transport mechanism with nodermailer\n  var transporter;\n  var customTransport = config.getItem('mailer.transport');\n  if(config.getItem('testMode.noEmail')) {\n    transporter = nodemailer.createTransport(require('nodemailer-stub-transport')());\n  } else if(customTransport) {\n    transporter = nodemailer.createTransport(customTransport(config.getItem('mailer.options')));\n  } else {\n    transporter = nodemailer.createTransport(config.getItem('mailer.options'));\n  }\n\n  this.sendEmail = function(templateName, email, locals) {\n    // load the template and parse it\n    var templateFile = config.getItem('emails.' + templateName + '.template');\n    if(!templateFile) {\n      return BPromise.reject('No template found for \"' + templateName + '\".');\n    }\n    var template = fs.readFileSync(templateFile, 'utf8');\n    if(!template) {\n      return BPromise.reject('Failed to locate template file: ' + templateFile);\n    }\n    var body = ejs.render(template, locals);\n    // form the email\n    var subject = config.getItem('emails.' + templateName + '.subject');\n    var format = config.getItem('emails.' + templateName + '.format');\n    var mailOptions = {\n      from: config.getItem('mailer.fromEmail'),\n      to: email,\n      subject: subject\n    };\n    if(format==='html') {\n      mailOptions.html = body;\n    } else {\n      mailOptions.text = body;\n    }\n    if(config.getItem('testMode.debugEmail')) {\n      console.log(mailOptions);\n    }\n    // send the message\n    var sendEmail = BPromise.promisify(transporter.sendMail, {context: transporter});\n    return sendEmail(mailOptions);\n  };\n\n  return this;\n\n};\n","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/gulpfile.js":"var gulp   = require('gulp'),\n  jshint = require('gulp-jshint'),\n  stylish = require('jshint-stylish'),\n  mocha = require('gulp-mocha');\n\ngulp.task('lint', function() {\n  return gulp.src(['./lib/**/*.js', './test/*.js'])\n    .pipe(jshint({node: true, mocha: true}))\n    .pipe(jshint.reporter(stylish))\n    .pipe(jshint.reporter('fail'));\n});\n\ngulp.task('middleware-test', ['lint'], function () {\n  return gulp.src(['test/middleware.spec.js'], {read: false})\n    .pipe(mocha({timeout: 2000}));\n});\n\ngulp.task('dbauth-test', ['middleware-test'], function () {\n  return gulp.src(['test/dbauth.spec.js'], {read: false})\n    .pipe(mocha({timeout: 2000}));\n});\n\ngulp.task('session-test', ['dbauth-test'], function () {\n  return gulp.src(['test/session.spec.js'], {read: false})\n    .pipe(mocha({timeout: 2000}));\n});\n\ngulp.task('mailer-test', ['dbauth-test'], function () {\n  return gulp.src(['test/mailer.spec.js'], {read: false})\n    .pipe(mocha({timeout: 2000}));\n});\n\ngulp.task('user-test', ['dbauth-test'], function () {\n  return gulp.src(['test/user.spec.js'], {read: false})\n    .pipe(mocha({timeout: 2000}));\n});\n\ngulp.task('final-test', ['user-test'], function () {\n  return gulp.src(['test/test.js'], {read: false})\n    .pipe(mocha({timeout: 2000}));\n});\n\ngulp.task('default', ['final-test', 'user-test', 'mailer-test', 'session-test', 'middleware-test', 'lint']);","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/config/default.config.js":"var path = require('path');\n\n// These are the default settings that will be used if you don't override them in your config\nmodule.exports = {\n  security: {\n    defaultRoles: ['user'],\n    maxFailedLogins: 4,\n    lockoutTime: 300,\n    sessionLife: 86400,\n    tokenLife: 86400,\n    loginOnRegistration: false,\n    loginOnPasswordReset: false\n  },\n  local: {\n    usernameField: 'username',\n    passwordField: 'password'\n  },\n  session: {\n    adapter: 'memory'\n  },\n  dbServer: {\n    protocol: 'http://',\n    host: 'localhost:5984',\n    designDocDir: path.join(__dirname, '/designDocs'),\n    userDB: 'sl_users',\n    // CouchDB's _users database. Each session generates the user a unique login and password. This is not used with Cloudant.\n    couchAuthDB: '_users'\n  },\n  emails: {\n    confirmEmail: {\n      subject: 'Please confirm your email',\n      template: path.join(__dirname, '../templates/email/confirm-email.ejs'),\n      format: 'text'\n    },\n    forgotPassword: {\n      subject: 'Your password reset link',\n      template: path.join(__dirname, '../templates/email/forgot-password.ejs'),\n      format: 'text'\n    }\n  }\n};","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/designDocs/user-design.js":"module.exports = {\n  auth: {\n    views: {\n      email: function(doc) {\n        if(doc.email) {\n          emit(doc.email, null);\n        } else if(doc.unverifiedEmail.email) {\n          emit(doc.unverifiedEmail.email, null);\n        }\n      },\n      username: function(doc) {\n        emit(doc._id, null);\n      },\n      verifyEmail: function(doc) {\n        if(doc.unverifiedEmail && doc.unverifiedEmail.token) {\n          emit(doc.unverifiedEmail.token, null);\n        }\n      },\n      emailUsername: function(doc) {\n        emit(doc._id, null);\n        if(doc.email) {\n          emit(doc.email, null);\n        } else if(doc.unverifiedEmail.email) {\n          emit(doc.unverifiedEmail.email, null);\n        }\n      },\n      passwordReset: function(doc) {\n        if(doc.forgotPassword && doc.forgotPassword.token) {\n          emit(doc.forgotPassword.token, null);\n        }\n      },\n      session: function(doc) {\n        if(doc.session) {\n          for(var key in doc.session) {\n            if(doc.session.hasOwnProperty(key)) {\n              emit(key, doc._id);\n            }\n          }\n        }\n      },\n      expiredKeys: function(doc) {\n        if(doc.session) {\n          for(var key in doc.session) {\n            if(doc.session.hasOwnProperty(key) && doc.session[key].expires) {\n              emit(doc.session[key].expires, {key: key, user: doc._id});\n            }\n          }\n        }\n      }\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/lib/dbauth/cloudant.js":"'use strict';\nvar url = require('url');\nvar BPromise = require('bluebird');\nvar request = require('superagent');\nvar util = require('./../util');\n\n// This is not needed with Cloudant\nexports.storeKey = function() {\n  return BPromise.resolve();\n};\n\n// This is not needed with Cloudant\nexports.removeKeys = function() {\n  return BPromise.resolve();\n};\n\n// This is not needed with Cloudant\nexports.initSecurity = function() {\n  return BPromise.resolve();\n};\n\nexports.authorizeKeys = function(user_id, db, keys, permissions, roles) {\n  var keysObj = {};\n  if(!permissions) {\n    permissions = ['_reader', '_replicator'];\n  }\n  permissions = permissions.concat(roles || []);\n  permissions.unshift('user:' + user_id);\n  // If keys is a single value convert it to an Array\n  keys = util.toArray(keys);\n  // Check if keys is an array and convert it to an object\n  if(keys instanceof Array) {\n    keys.forEach(function(key) {\n      keysObj[key] = permissions;\n    });\n  } else {\n    keysObj = keys;\n  }\n  // Pull the current _security doc\n  return getSecurityCloudant(db)\n    .then(function(secDoc) {\n      if(!secDoc._id) {\n        secDoc._id = '_security';\n      }\n      if(!secDoc.cloudant) {\n        secDoc.cloudant = {};\n      }\n      Object.keys(keysObj).forEach(function(key) {\n        secDoc.cloudant[key] = keysObj[key];\n      });\n      return putSecurityCloudant(db, secDoc);\n    });\n};\n\nexports.deauthorizeKeys = function(db, keys) {\n  // cast keys to an Array\n  keys = util.toArray(keys);\n  return getSecurityCloudant(db)\n    .then(function(secDoc) {\n      var changes = false;\n      if(!secDoc.cloudant) {\n        return BPromise.resolve(false);\n      }\n      keys.forEach(function(key) {\n        if(secDoc.cloudant[key]) {\n          changes = true;\n          delete secDoc.cloudant[key];\n        }\n      });\n      if(changes) {\n        return putSecurityCloudant(db, secDoc);\n      } else {\n        return BPromise.resolve(false);\n      }\n    });\n};\n\nexports.getAPIKey = function(db) {\n  var parsedUrl = url.parse(db.getUrl());\n  parsedUrl.pathname = '/_api/v2/api_keys';\n  var finalUrl = url.format(parsedUrl);\n  return BPromise.fromNode(function(callback) {\n    request.post(finalUrl)\n      .set(db.getHeaders())\n      .end(callback);\n  })\n    .then(function(res) {\n      var result = JSON.parse(res.text);\n      if(result.key && result.password && result.ok === true) {\n        return BPromise.resolve(result);\n      } else {\n        return BPromise.reject(result);\n      }\n    });\n};\n\nvar getSecurityCloudant = exports.getSecurityCloudant = function (db) {\n  var finalUrl = getSecurityUrl(db);\n  return BPromise.fromNode(function(callback) {\n    request.get(finalUrl)\n      .set(db.getHeaders())\n      .end(callback);\n  })\n    .then(function(res) {\n      return BPromise.resolve(JSON.parse(res.text));\n    });\n};\n\nvar putSecurityCloudant = exports.putSecurityCloudant = function (db, doc) {\n  var finalUrl = getSecurityUrl(db);\n  return BPromise.fromNode(function(callback) {\n    request.put(finalUrl)\n      .set(db.getHeaders())\n      .send(doc)\n      .end(callback);\n  })\n    .then(function(res) {\n      return BPromise.resolve(JSON.parse(res.text));\n    });\n};\n\nfunction getSecurityUrl(db) {\n  var parsedUrl = url.parse(db.getUrl());\n  parsedUrl.pathname = parsedUrl.pathname + '_security';\n  return url.format(parsedUrl);\n}","/home/travis/build/npmtest/node-npmtest-superlogin/node_modules/superlogin/lib/dbauth/couchdb.js":"'use strict';\nvar BPromise = require('bluebird');\nvar util = require('../util');\n\nmodule.exports = function(couchAuthDB) {\n\n  this.storeKey = function (username, key, password, expires, roles) {\n    if(roles instanceof Array) {\n      // Clone roles to not overwrite original\n      roles = roles.slice(0);\n    } else {\n      roles = [];\n    }\n    roles.unshift('user:' + username);\n    var newKey = {\n      _id: 'org.couchdb.user:' + key,\n      type: 'user',\n      name: key,\n      user_id: username,\n      password: password,\n      expires: expires,\n      roles: roles\n    };\n    return couchAuthDB.put(newKey)\n      .then(function () {\n        newKey._id = key;\n        return BPromise.resolve(newKey);\n      });\n  };\n\n  this.removeKeys = function(keys) {\n    keys = util.toArray(keys);\n    var keylist = [];\n    // Transform the list to contain the CouchDB _user ids\n    keys.forEach(function(key) {\n      keylist.push('org.couchdb.user:' + key);\n    });\n    var toDelete = [];\n    return couchAuthDB.allDocs({keys: keylist})\n      .then(function(keyDocs) {\n        keyDocs.rows.forEach(function(row) {\n          if(!row.error && !row.value.deleted) {\n            var deletion = {\n              _id: row.id,\n              _rev: row.value.rev,\n              _deleted: true\n            };\n            toDelete.push(deletion);\n          }\n        });\n        if(toDelete.length) {\n          return couchAuthDB.bulkDocs(toDelete);\n        } else {\n          return BPromise.resolve(false);\n        }\n      });\n  };\n\n  this.initSecurity = function(db, adminRoles, memberRoles) {\n    var changes = false;\n    return db.get('_security')\n      .then(function (secDoc) {\n        if (!secDoc.admins) {\n          secDoc.admins = {names: [], roles: []};\n        }\n        if (!secDoc.admins.roles) {\n          secDoc.admins.roles = [];\n        }\n        if (!secDoc.members) {\n          secDoc.members = {names: [], roles: []};\n        }\n        if (!secDoc.members.roles) {\n          secDoc.admins.roles = [];\n        }\n        adminRoles.forEach(function(role) {\n          if(secDoc.admins.roles.indexOf(role) === -1) {\n            changes = true;\n            secDoc.admins.roles.push(role);\n          }\n        });\n        memberRoles.forEach(function(role) {\n          if(secDoc.members.roles.indexOf(role) === -1) {\n            changes = true;\n            secDoc.members.roles.push(role);\n          }\n        });\n        if(changes) {\n          return putSecurityCouch(db, secDoc);\n        } else {\n          return BPromise.resolve(false);\n        }\n      });\n  };\n\n  this.authorizeKeys = function (user_id, db, keys) {\n    var secDoc;\n    // Check if keys is an object and convert it to an array\n    if(typeof keys === 'object' && !(keys instanceof Array)) {\n      var keysArr = [];\n      Object.keys(keys).forEach(function(theKey) {\n        keysArr.push(theKey);\n      });\n      keys = keysArr;\n    }\n    // Convert keys to an array if it is just a string\n    keys = util.toArray(keys);\n    return db.get('_security')\n      .then(function (doc) {\n        secDoc = doc;\n        if (!secDoc.members) {\n          secDoc.members = {names: [], roles: []};\n        }\n        if (!secDoc.members.names) {\n          secDoc.members.names = [];\n        }\n        var changes = false;\n        keys.forEach(function (key) {\n          var index = secDoc.members.names.indexOf(key);\n          if (index === -1) {\n            secDoc.members.names.push(key);\n            changes = true;\n          }\n        });\n        if (changes) {\n          return putSecurityCouch(db, secDoc);\n        } else {\n          return BPromise.resolve(false);\n        }\n      });\n  };\n\n  this.deauthorizeKeys = function (db, keys) {\n    var secDoc;\n    keys = util.toArray(keys);\n    return db.get('_security')\n      .then(function (doc) {\n        secDoc = doc;\n        if (!secDoc.members || !secDoc.members.names) {\n          return BPromise.resolve(false);\n        }\n        var changes = false;\n        keys.forEach(function (key) {\n          var index = secDoc.members.names.indexOf(key);\n          if (index > -1) {\n            secDoc.members.names.splice(index, 1);\n            changes = true;\n          }\n        });\n        if (changes) {\n          return putSecurityCouch(db, secDoc);\n        } else {\n          return BPromise.resolve(false);\n        }\n      });\n  };\n\n  function putSecurityCouch(db, doc) {\n    return db.request({\n      method: 'PUT',\n      url: '_security',\n      body: doc\n    });\n  }\n\n  return this;\n\n};\n\n"}